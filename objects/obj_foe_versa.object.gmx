<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_orb_mask</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-10</depth>
  <persistent>0</persistent>
  <parentName>obj_foe_par</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//instance_destroy()
//Orb Engine 4
//By Alain Galvan
//Last Revision: 06/15/12
////////////////////////////////////////////////////////////////////////////////////////
//Initial Code
//This has been set so that one can easily modify the physics that influence orb while at
//the same time keep individual ai easily modifiable in the event off the need of
//ai or other entities.
////////////////////////////////////////////////////////////////////////////////////////
//Arrow Controls
////////////////////////////////////////////////////////////////////////////////////////
left=false
right=false
up=false
down=false
////////////////////////////////////////////////////////////////////////////////////////
//Physics
////////////////////////////////////////////////////////////////////////////////////////
//Constants
hpmax=3
hp=3
airgravspd=1
watergravspd=0.25
maxjump=2
jumpspd=24 //*(8)
airfric=0.5
groundfric=1
maxspd=18
gravspd=1
waterstage=0
z=-64


//Dynamic Vars
slopedir=0
flash=1
hspd=0
vspd=0
accspd=1
dir=1
max_slope=2
inair=0
hold=0
jump=0
jumpstatus=0
inwater=0
hdir=0
hp=hpmax
Speed=0
Direction=0
dirprevious=Direction
hue=floor(random(255)+128)
flash=1
gem=0
block=obj_block_par
water=obj_water_par
ladder=obj_ladder_par
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>intel = 30;
alarm[0] = room_speed / intel;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if instance_exists(obj_orb) {

    if point_distance(x,y,obj_orb.x,obj_orb.y)&lt;800
    {
    if obj_orb.x &gt; x
       {
       right=true
       left=false
       }

    if obj_orb.x&lt;x
       {
       right=false
       left=true
       }

    if obj_orb.y&lt;y-64
       {
       up=true
       }
       if obj_orb.y&gt;y-64 and obj_orb.y&lt;y+64
       {
       up=false
       }
    }
    else
    {
    left=false
    right=false
    up=false
    }

}    
alarm[0] = floor(random(room_speed/intel)+1)
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Direction=point_direction(x,y,xprevious,yprevious)
Speed=point_distance(x,y,xprevious,yprevious)
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>dirprevious=Direction
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Orb Engine 4
//By Alain Galvan
//Last Revision: 10/10/12
////////////////////////////////////////////////////////////////////////////////////////
//Loop Code
//Orb Engine Revision 4 
////////////////////////////////////////////////////////////////////////////////////////
//Movement &amp; Friction
////////////////////////////////////////////////////////////////////////////////////////
//PC Controls 
//Controlled by alarm[0]

//Movement Mechanics
if left==true {hspd=max(-maxspd,hspd - accspd)}
if right=true {hspd=min(maxspd,hspd + accspd)}

//Air Mechanics
if(place_meeting(x,y+1,block)==1) 
{
inair = 0;
}  
else 
{
inair = 1;
}
//Air Friction
if(inair==1) 
{
    vspd+= gravspd;
    if ! left=true &amp;&amp; ! right=true{hspd = max(0,abs(hspd)-airfric)*sign(hspd);}
}
//Ground Friction
if(inair==0) 
{
    jump = 0;
    if ! left=true &amp;&amp; ! right=true{hspd = max(0,abs(hspd)-groundfric)*sign(hspd);}
}

////////////////////////////////////////////////////////////////////////////////////////
//Jump
////////////////////////////////////////////////////////////////////////////////////////
switch (jumpstatus)
{
//Double Jump
case 0:
if up=true {
    if(inair==0 &amp;&amp; hold==0) {
        vspd  = -jumpspd;
        hold = 1;
        jump = 1;
    }
    if(jump&gt;=1 &amp;&amp; hold==0 &amp;&amp; jump&lt;maxjump) {
        vspd  = -jumpspd;
        hold = 1;
        jump+= 1;
    }
} 
else {hold = 0}
break;
case 1:
//Reflection System

break;
}
////////////////////////////////////////////////////////////////////////////////////////
//Motion
////////////////////////////////////////////////////////////////////////////////////////
//Horizontal Motion
repeat(ceil(abs(hspd))) 
{
var blk, mov, slp;
blk = place_meeting(x+sign(hspd),y,block);
mov = 0;
//Slope Mechanics UP
if(blk==1) and up=true
{
hspd*= -1.005;
} 
else
if(blk==1) 
{ 
//Wall Collision
if(mov==0) 
{            
hspd = 0;                
}
} 
else 
{
//Slope Mechanics DOWN

if(mov==0) 
{ 
x+= sign(hspd);            
}
}
}

//Vertical Motion
if vspd&gt;120 {vspd=120}
if vspd&lt;-120 {vspd=-120}
repeat(ceil(abs(vspd))) 
{
//Collision Vertically
if(place_meeting(x,y+sign(vspd),block)==1) and up=true 
{
vspd*= -1.005;
} 
else
if(place_meeting(x,y+sign(vspd),block)==1) 
{
vspd = 0;
} 
else 
{
//Vertical Mechanic
if(vspd!=0) 
{
y+= sign(vspd);
}
}
}


////////////////////////////////////////////////////////////////////////////////////////
//Water
////////////////////////////////////////////////////////////////////////////////////////
if instance_position(x,y,water) {inwater=1 gravspd=watergravspd}
if ! instance_position(x,y,water) and ! waterstage=1 {inwater=0 gravspd=airgravspd}
//Swimming
if up=true
{if inwater=1 {vspd=max(-maxspd/2,vspd - accspd)}}
if down=true
{if inwater=1 {vspd=min(maxspd/2,vspd + accspd)}}
////////////////////////////////////////////////////////////////////////////////////////
//Border Control
////////////////////////////////////////////////////////////////////////////////////////
if y&gt;room_height+64
{instance_destroy()}

if x&lt;8
{x=8 hspd=0 hspeed=0}

if x&gt;room_width-8
{x=room_width-8 hspeed=0 hspd=0}

if y&lt;8
{y=8 vspeed=0 vspd=0}
////////////////////////////////////////////////////////////////////////////////////////
//Ghosts
////////////////////////////////////////////////////////////////////////////////////////
image_blend=make_color_hsv(hue,255,255)
hue+=1
if hue&gt;255 {hue=0}

if (dirprevious-Direction)&gt;=180 dirprevious-=360
//Makes sure that difference isn't too high
if (dirprevious-Direction)&lt;=-180 dirprevious+=360
//Makes sure the difference isn't too low
//Both these are necessary because when you are going at same Direction 5, then 355
//it loop around completely
imgalpha=.15*100/40
//This sets the alpha at which to draw the first ghost
dir=(dirprevious+Direction)/2
//This is the average of the previous and current direction
//Dir is what direction the ghost trail is being built-up in
xx=xprevious
yy=yprevious
//This is where the ghosts are started to be created
repeat(Speed/100*global.blurvar) //Repeat as many times as there is space between the current and previous position
{
 with (instance_create(xx,yy,obj_foe_versa_blur)) {foeid=other.id image_alpha=other.imgalpha image_blend=other.image_blend}
 //Make a ghost at the correct alpha and color
 xx+=lengthdir_x(100/global.blurvar,dir)
 yy+=lengthdir_y(100/global.blurvar,dir)
 //Both these move where the ghosts are created towards the right spot a bit
 dir-=(dirprevious-Direction)/Speed
 //This increases the dir variable at a rate that makes the curve correctly
 imgalpha+=.05/(Speed/100*global.blurvar)
  //Increases the alpha, so it creates a smoothly fading line,
 //rather than one that fades in blocks
 //This should be equal to what the ghost is decreasing by divided by (Speed/100*40)
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if instance_exists(obj_orb) 
{
if collision_point(x,y,obj_orb,1,0) and obj_orb.Speed&gt;30
{
hp=0
hspd*=-1
vspd*=-1
obj_orb.hspd*=-1
obj_orb.vspd*=-1
sound_play(sou_sfx_hit)//Play hitsound.
flash=-1//Flash.
alarm[1]=1//Blinks Flash.
alarm[2]=30//Alarm to stop flash.
}
if collision_point(x,y,obj_orb,1,0) and obj_orb.Speed&lt;30
{
with (obj_orb) {instance_destroy()}
}
}
if hp&lt;=0
{
instance_destroy();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Orb Engine 4
//By Alain Galvan
//Last Revision: 06/15/12
////////////////////////////////////////////////////////////////////////////////////////
//Draw Code
//This is the script that is in charge of controlling all Graphics of Orb. THis script is 
//programmed such that it could work in both a 2D environment or a 3D environment. 
////////////////////////////////////////////////////////////////////////////////////////

d3d_set_lighting(false) 
d3d_set_hidden(false);
    var tex0,tex1,tex2;
  tex0 = sprite_get_texture(spr_foe_anti,0);
  tex1 = sprite_get_texture(spr_foe_anti,1);
  tex2 = sprite_get_texture(spr_foe_anti,2);
  draw_set_blend_mode(bm_normal)
  draw_set_color(image_blend)
  d3d_draw_floor(xprevious-128,yprevious-128,z,xprevious+128,yprevious+128,z,tex2,1,1);
  
  //d3d_draw_floor(xprevious-32,yprevious-32,z,xprevious+32,yprevious+32,z,tex0,1,1);
  draw_set_color(c_white)
  //d3d_draw_floor(xprevious-32,yprevious-32,z,xprevious+32,yprevious+32,z,tex1,1,1);
draw_set_blend_mode(bm_normal)

d3d_set_hidden(true);

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>24,24</point>
    <point>24,24</point>
  </PhysicsShapePoints>
</object>
