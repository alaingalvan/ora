<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_orb_mask</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-10</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Orb Engine 4
//By Alain Galvan
//Last Revision: 06/15/12
////////////////////////////////////////////////////////////////////////////////////////
//Initial Code
//This has been set so that one can easily modify the physics that influence orb while at
//the same time keep individual ai easily modifiable in the event off the need of
//ai or other entities.
////////////////////////////////////////////////////////////////////////////////////////
//Arrow Controls
////////////////////////////////////////////////////////////////////////////////////////
left=keyboard_check(ord('A'))
right=keyboard_check(ord('D'))
up=keyboard_check(ord('W'))
down=keyboard_check(ord('S'))
////////////////////////////////////////////////////////////////////////////////////////
//Physics
////////////////////////////////////////////////////////////////////////////////////////
//Constants
hpmax=3
airgravspd=1
watergravspd=0.25
maxjump=2
jumpspd=16
airfric=0.5
groundfric=1
maxspd=12
gravspd=1
waterstage=0
z=-64


//Dynamic Vars
slopedir=0
flash=1
hspd=0
vspd=0
accspd=1
dir=1
inair=0
hold=0
jump=0
jumpstatus=0
inwater=0
hdir=0
hp=hpmax
Speed=0
Direction=0
dirprevious=Direction
hue=obj_orb.hue+128
gem=0
movetimerr=0
movetimerl=0

//Constants
block=obj_block_par
bounce=obj_bounce_par
water=obj_water_par
ladder=obj_ladder_par
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>instance_create(x,y,obj_orb2_death)
obj_orb_blur.hue=hue
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Direction=point_direction(x,y,xprevious,yprevious)
Speed=point_distance(x,y,xprevious,yprevious)
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>dirprevious=Direction
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>  //Orb Engine 4
  //By Alain Galvan
  //Last Revision: 10/26/12
  ////////////////////////////////////////////////////////////////////////////////////////
  //Implement: 
  //Allow the 
  //New Motion engine that supports:
  //Slopes
  //Higher max Hspeed
  //Screen Zooms out and averages on bouncing at high frequencies. 
  //Implement Box Physics
  //Fullscreen Fix
  //Options Implemtation
  //Adjust tutorial image to scale with screen.
  //Add more contrast to menu buttons.
  //Make it so that blocks no longer kill you if falling, only when you're crushed. 
  //Make title screen for level so player knows where they're at. 
  //Level 3, make it so that you have a button that can add boxes to the level. 
  ////////////////////////////////////////////////////////////////////////////////////////
  //Loop Code
  //Orb Engine Revision 4 
  ////////////////////////////////////////////////////////////////////////////////////////
  //Movement &amp; Friction
  ////////////////////////////////////////////////////////////////////////////////////////
  //PC Controls 

  left = keyboard_check(ord('A'))
   right = keyboard_check(ord('D'))
   up = keyboard_check(ord('W'))
   down = keyboard_check(ord('S'))

  //Gamepad Controls

  if os_type = os_windows or os_type = os_macosx {
      if joystick_exists(2) {
          switch (joystick_direction(2)) {
              case vk_numpad1:
                  left = true;
                  if inwater = 1 {
                      down = true
                  };
                  break;
              case vk_numpad2:
                  if inwater = 1 {
                      down = true
                  };
                  break;
              case vk_numpad3:
                  right = true;
                  if inwater = 1 {
                      down = true
                  };
                  break;
              case vk_numpad4:
                  left = true;
                  break;
              case vk_numpad6:
                  right = true;
                  break;
              case vk_numpad7:
                  left = true;
                  if inwater = 1 {
                      up = true;
                  }
                  break;
              case vk_numpad8:
                  if inwater = 1 {
                      up = true;
                  }
                  break;
              case vk_numpad9:
                  right = true;
                  if inwater = 1 {
                      up = true;
                  }
                  break;
          }
          if joystick_check_button(2, 1) {
              up = true;
          }
          if joystick_check_button(2, 7) {
          if instance_exists(obj_orb)
          {
              x = obj_orb.x
              y = obj_orb.y
              }
          }
      }
  }

  //Movement Mechanics

  if left == true {
      if hspd &gt; -maxspd {
          hspd -= accspd
      }
  }
  if right = true {
      if hspd &lt; maxspd {
          hspd += accspd
      }
  }

  //Air Mechanics
  if (place_meeting(x, y + 1, block) == 1) {
      inair = 0;
  } else {
      inair = 1;
  }
  //Air Friction
  if (inair == 1) {
      vspd += gravspd;
      if !left = true &amp;&amp; !right = true {
          hspd = max(0, abs(hspd) - airfric) * sign(hspd);
      }
      //Insert new deccel code for air

  }
  //Ground Friction
  if (inair == 0) {
      jump = 0;
      if !left = true &amp;&amp; !right = true {
          hspd = max(0, abs(hspd) - groundfric) * sign(hspd);
      }
      //insert new decel code for ground
  }

  ////////////////////////////////////////////////////////////////////////////////////////
  //Jump
  ////////////////////////////////////////////////////////////////////////////////////////
  if up = true {
      if (inair == 0 &amp;&amp; hold == 0) {

          vspd = -jumpspd;
          hold = 1;
          jump = 1;
      }
      if (jump &gt;= 1 &amp;&amp; hold == 0 &amp;&amp; jump &lt; maxjump) {

          vspd = -jumpspd;
          hold = 1;
          jump += 1;
      }
  } else {
      hold = 0
  }

  ////////////////////////////////////////////////////////////////////////////////////////
  //Motion
  ////////////////////////////////////////////////////////////////////////////////////////
  //Horizontal Motion
  repeat(ceil(abs(hspd))) {
      var blk, wtr;
      blk = place_meeting(x + sign(hspd), y, block);
      wtr = place_meeting(x + sign(hspd), y, water);
      mov = 0;
      //Slope Mechanics UP
      if (blk == 1) and up = true and wtr = false {

          hspd *= -1.005;
          vspd *= 1.005;


      } else if (blk == 1) {
          //Wall Collision
          if (mov == 0) {
              hspd = 0;
              bounce = false;
          }
      } else {
          //Slope Mechanics DOWN

          if (mov == 0) {
              x += sign(hspd);
              bounce = false;
          }
      }
  }

  //Vertical Motion
  if vspd &gt; 120 {
      vspd = 120
  }
  if vspd &lt; -120 {
      vspd = -120
  }
  repeat(ceil(abs(vspd))) {
      //Collision Vertically
      if place_meeting(x, y + sign(vspd), block) == 1 and place_meeting(x, y + sign(vspd), water) != 1 and up = true {

          vspd *= -1.005;
          hspd *= 1.005;


      }
      if place_meeting(x, y + sign(vspd), obj_block_jumppad) == 1 {

          vspd *= -1.5;
          hspd *= 1.005;


      } else if (place_meeting(x, y + sign(vspd), block) == 1) {
          vspd = 0;
      } else {
          //Vertical Mechanic
          if (vspd != 0) {
              y += sign(vspd);
          }
      }
  }


  ////////////////////////////////////////////////////////////////////////////////////////
  //Water
  ////////////////////////////////////////////////////////////////////////////////////////
  if instance_position(x, y, water) {
      inwater = 1
      gravspd = watergravspd
  }
  if !instance_position(x, y, water) and!waterstage = 1 {
      inwater = 0
      gravspd = airgravspd
  }
  //Swimming
  if up = true {
      if inwater = 1 {
          vspd = max(-maxspd / 2, vspd - accspd)
      }
  }

  if down = true {
      if inwater = 1 {
          vspd = min(maxspd / 2, vspd + accspd)
      }
  }
  ////////////////////////////////////////////////////////////////////////////////////////
  //Border Control
  ////////////////////////////////////////////////////////////////////////////////////////
  if y &gt; room_height + 128 {
      instance_destroy()
  }

  if x &lt; 8 {
      x = 8 hspd = 0 hspeed = 0
  }

  if x &gt; room_width - 8 {
      x = room_width - 8 hspeed = 0 hspd = 0
  }

  if y &lt; 8 {
      y = 8 vspeed = 0 vspd = 0
  }
  ////////////////////////////////////////////////////////////////////////////////////////
  //Ghosts
  ////////////////////////////////////////////////////////////////////////////////////////
  image_blend = make_color_hsv(hue, 255, 255)
   hue += 1
  if hue &gt; 255 {
      hue = 0
  }

  if (dirprevious - Direction) &gt;= 180 {
      dirprevious -= 360
  }
  if (dirprevious - Direction) &lt;= -180 {
      dirprevious += 360
  }

  //Alpha of first ghost
  imgalpha = .375

  //Average of change in direction.
  dir = (dirprevious + Direction) / 2

  //temp vars for script.
  xx = xprevious
   yy = yprevious

  //This is where the ghosts are started to be created
  //Repeat as many times as there is space between the current and previous position
  repeat(Speed / 100 * global.blurvar) {
      with(instance_create(xx, yy, obj_orb_blur2)) {
          image_alpha = other.imgalpha image_blend = other.image_blend
      }

      xx += lengthdir_x(100 / global.blurvar, dir)
      yy += lengthdir_y(100 / global.blurvar, dir)
      //Both these move where the ghosts are created towards the right spot a bit
      dir -= (dirprevious - Direction) / Speed
      //This increases the dir variable at a rate that makes the curve correctly
      imgalpha += .05 / (Speed / 100 * global.blurvar)
      //Increases the alpha, so it creates a smoothly fading line,
      //rather than one that fades in blocks
      //This should be equal to what the ghost is decreasing by divided by (Speed/100*40)
  }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Orb Engine 4
//By Alain Galvan
//Last Revision: 06/15/12
////////////////////////////////////////////////////////////////////////////////////////
//Draw Code
//This is the script that is in charge of controlling all Graphics of Orb. THis script is 
//programmed such that it could work in both a 2D environment or a 3D environment. 
////////////////////////////////////////////////////////////////////////////////////////
{
d3d_set_lighting(false) 
d3d_set_hidden(false);
    var tex0,tex1,tex2;
  tex0 = sprite_get_texture(spr_orb,0);
  tex1 = sprite_get_texture(spr_orb,1);
  tex2 = sprite_get_texture(spr_orb,2);
  draw_set_blend_mode(bm_add)
  draw_set_color(image_blend)
  d3d_draw_floor(xprevious-128,yprevious-128,z,xprevious+128,yprevious+128,z,tex2,1,1);
  
  d3d_draw_floor(xprevious-32,yprevious-32,z,xprevious+32,yprevious+32,z,tex0,1,1);
  draw_set_color(c_white)
  d3d_draw_floor(xprevious-32,yprevious-32,z,xprevious+32,yprevious+32,z,tex1,1,1);
draw_set_blend_mode(bm_normal)

d3d_set_hidden(true);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
