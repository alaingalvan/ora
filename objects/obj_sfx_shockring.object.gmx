<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-1000000</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
ww = 25;            //Width of the "ring" effect
radius = 0;         //Size check variable
r_max = 120;        //Maximum radius of the effect
spd = 1;            //Expansion speed
d = 360/15;         //Ring "segments" to be drawn
z = 0

//get the texture components from the surface
if instance_exists(obj_camera)
{
tex = surface_get_texture(obj_camera.view_surface[0]);
srf_w = surface_get_width(obj_camera.view_surface[0]);
srf_h = surface_get_height(obj_camera.view_surface[0]);
tex_w = texture_get_width(tex);
tex_h = texture_get_height(tex);
}
else instance_destroy();
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*
z = 0
convert_prepare(global.cam_xfrom,global.cam_yfrom,global.cam_zfrom,global.cam_xto,global.cam_yto,global.cam_zto,global.cam_up_x,global.cam_up_y,global.cam_up_z,global.cam_fov,window_get_width()/window_get_height());
// Create the animation variables for the relic
relic_rx = 0;
relic_hover = 0;
// Create circle model pieces
circle_model1 = d3d_model_create();
circle_model2 = d3d_model_create();
pi180 = (pi/180)
light_animate = 0;
s = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*
// Update size
s += (1-s)/120;

// Destroy circle when size is big enough
if s &gt; 0.95 then instance_destroy();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
if radius &lt; r_max radius += spd else instance_destroy();

var o, c, xx, yy, a, sx, sy;

o = (-radius + r_max) / 5;      //Distortion offset
c = 0;                          //Multiplier for ring segments
a = 1 / (r_max / spd);          //Alpha modifier
sx = tex_w / srf_w;             //Texture x coord
sy = tex_h / srf_h;             //texture y coord

//Draw the inner part of the ring
draw_primitive_begin_texture(pr_trianglestrip, tex);
repeat(16)
    {
    xx = x + lengthdir_x(radius, c * d);
    yy = y + lengthdir_y(radius, c * d);
    draw_vertex_texture_color(xx, yy, sx * (xx + lengthdir_x(o, c * d)), sy * (yy + lengthdir_y(o, c * d)), c_white, image_alpha);
    xx = x + lengthdir_x(radius - ww, c * d);
    yy = y + lengthdir_y(radius - ww, c * d);
    draw_vertex_texture_color(xx, yy, sx * xx, sy * yy, c_white, 0);
    c += 1;
    }
draw_primitive_end();
c = 0
//Draw the outer part of the ring
draw_primitive_begin_texture(pr_trianglestrip, tex);
repeat(16)
    {
    xx = x + lengthdir_x(radius + ww, c * d);
    yy = y + lengthdir_y(radius + ww, c * d);
    draw_vertex_texture_color(xx, yy, sx * xx, sy * yy, c_white, 0);
    xx = x + lengthdir_x(radius, c * d);
    yy = y + lengthdir_y(radius, c * d);
    draw_vertex_texture_color(xx, yy, sx * (xx + lengthdir_x(o, c * d)), sy * (yy + lengthdir_y(o, c * d)), c_white, image_alpha);
    c += 1;
    }
draw_primitive_end();
image_alpha -= a;


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*
// Convert 3D coordinates to 2D screen coordinates.
// Convert_3d(targetx,targety,targetz,xfrom,from,zfrom,view)
convert_3d(x, y, z+sin(relic_hover)*0.5,global.cam_xfrom,global.cam_yfrom,global.cam_zfrom,0);
fx_2d = x_2d;
fy_2d = y_2d;
//distance.
convert_3d(x+lengthdir_x(global.cam_distance,global.cam_angle_x+90), y+lengthdir_y(global.cam_distance,global.cam_angle_y+90), z+sin(relic_hover)*0.5,global.cam_xfrom,global.cam_yfrom,global.cam_zfrom,0);
d = sqrt((x_2d-fx_2d)*(x_2d-fx_2d) + (y_2d-fy_2d)*(y_2d-fy_2d))/275;

// Draw the 2 rings made up of vertexes to create the effect 
d3d_model_clear(circle_model1);
d3d_model_clear(circle_model2);

light_animate += random(0.25);
s = 10+sin(light_animate)*3;
d3d_model_primitive_begin(circle_model1, pr_trianglestrip);
d3d_model_primitive_begin(circle_model2, pr_trianglestrip);

var i;
i = -15;
repeat(25)
{
    i += 15;

    lx = cos(i * pi180) * d;
    ly = -sin(i * pi180) * d;

    xx = lx * s * 300;
    yy = ly * s * 300;
    tx = (fx_2d + xx) / 1280;
    ty = (fy_2d + yy) / 800;
    d3d_model_vertex_texture(circle_model1, fx_2d + xx, fy_2d + yy, 0, tx, ty);

    xx = lx * s * (150 + 150 * (s / 0.95));
    yy = ly * s * (150 + 150 * (s / 0.95));
    tx = (fx_2d + xx * (0.7 + 0.3 * (s / 0.95))) / 960;
    ty = (fy_2d + yy * (0.7 + 0.3 * (s / 0.95))) / 600;
    d3d_model_vertex_texture(circle_model1, fx_2d + xx, fy_2d + yy, 0, tx, ty);
    d3d_model_vertex_texture(circle_model2, fx_2d + xx, fy_2d + yy, 0, tx, ty);

    xx = lx * s * 300 * (s / 0.95);
    yy = ly * s * 300 * (s / 0.95);
    tx = (fx_2d + xx) / 960;
    ty = (fy_2d + yy) / 600;
    d3d_model_vertex_texture(circle_model2, fx_2d + xx, fy_2d + yy, 0, tx, ty);
}

d3d_model_primitive_end(circle_model1);
d3d_model_primitive_end(circle_model2);

draw_set_color(c_white);
d3d_model_draw(circle_model2, x, y, z, tex);
d3d_model_draw(circle_model1, x, y, z, tex);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
